<pre>
  OEP: 6
  Title: API for dApps (dAPI) and communication protocol for dAPI providers
  Author: Matus Zamborsky <zamborsky@gmail.com>
  Type: Standard
  Status: Draft
  Created: 2018-08-03
</pre>

==Abstract==

This proposal has two major parts:

* A Javascript API is proposed for dApps development. This dAPI allows dApps to communicate with Ontology blockchain and make requests for transfers, ONT ID registration and others, without requiring users to trust the dApp itself. The issue of trust is shifted to the dAPI provider.

* A Communication protocol is proposed for dAPI provider development. This allows multiple Wallet implementators to offer the same unified service to users of dApps and prevent fragmentation of dApp development.

==Motivation==

Currently a dApp will use one of the SDKs (Typescript, Java, Python, ...) to communicate with Ontology network. This setup has three main disadvantages:

1. User of the dApp will have to trust the dApp developer with his private keys and that information about transfers mediated through the dApp are legitimate.

2. Although the SDKs are very powerful, they are hard to use. A more streamlined API will allow developers to focus on the application itself.

3. Hard to implement integration to external signing mechanism (e.g.: Ledger, Trezor)

==Specification==
This proposal makes use of the following functions and definitions:

*'''SDK''', a software development kit implementing low level communication with the network and providing high level interface for dApps.

*'''dApp''', an application with decentralised characteristics running in web environment. The application uses Ontology network for value transfers, contracts enforcing and identification between participants.

*'''dAPI''', the API for dApps this OEP is proposing.

*'''dAPI provider''', an implementation of the dAPI in the form of web browser plugin or other means, where a user interaction with the provider can be injected into api call workflow (e.g.: confirming transfer).

*'''Notify event''', an event broadcasted from smart contract execution.

*'''NEOVM''', a lightweight virtual machine for execution of Neo/Ontology smart contracts.


===Components===
Although this proposal is bringing clear and simple API for the dApps, the individual functions can be divided into these components:

* '''Network''', a thin wrapper around the Ontology Node API, masking the complexity of rpc/rest calls and web-sockets with Request-Response facade.

* '''Asset''', functions for transferring assets between user account and others.

* '''Identity''', functions for interacting with own ONT-ID identity.

* '''SmartContract''', a high level wrapper around the Smart Contract invocation and deployment.

* '''Message''', functions for signing arbitrary messages.

* '''Utils''', a group of utility function for encoding and decoding the data from/to blockchain.

===Asynchronicity and error handling===
All the functions except '''Utils''' component are communicating with extension through asynchronious message channel. Therefore all the methods are returning Promises. 

The promises will be either resolved immediately if no interaction with user UI or blockchain is required or later when the user action takes place/blockchain responds. In case the call to method trigger an error, the error code is transmitted in rejected promise. Specific error codes are described with every method.

===Account/Identity management===
Because dAPI shifts the issue of trust from dApp to dApp provider, all account and identity management is external to the dApp. Therefore there are no methods which directly handle private keys. The dApp won't need to sign the transaction itself. 

Any time dApp makes a call that requires a private key to sign something (makeTransfer, sign), dApp provider will inform user about the action and prompt him for permission.

dApp provider can even forward the request to external signing mechanism as part of the process. This way the dApp does not need to specifically integrate with such mechanism.

===Encoding===
The interaction with dAPI often requires specification of '''Address''', '''Identity''', '''Contract address''' or '''Public Key'''. Those concepts are represented by string representation with specific encodings.

====Address====
* 34 bytes long
* using Base58 check encoding
* starts with A letter

====Contract address====
* 40 bytes long
* using Hex encoding

====Identity====
* 42 bytes long
* using Base58 check encoding for 34 byte suffix
* starts with 'did:ont:' prefix

====Public Key====
* 33/35 bytes long
* using Hex encoding

===Complex structures===
API specification is a complex document. Every method has some inputs and outputs. Although we use the primitive types (numbers, strings, booleans) whenever possible, there are places where a complex object is required. To precisely describe the structure of those objects, we'd chosen Typescript syntax.

===Network===
A network API consists of:

<pre>
type Network = 'MAIN' | 'TEST' | 'PRIVATE';
type Asset = 'ONT' | 'ONG';

function getGenerateBlockTime(): Promise<number | null>
function getNodeCount(): Promise<number>
function getBlockHeight(): Promise<number>
function getMerkleProof(txHash: string): Promise<MerkleProof>
function getStorage(contract: string, key: string): Promise<string>
function getAllowance(asset: Asset, fromAddress: string, toAddress: string): Promise<number>
function getBlock(block: number | string): Promise<Block>
function getTransaction(txHash: string): Promise<Transaction>
function getNetwork(): Network
function getBalance(address: string): Promise<Balance>
</pre>

For further explanation about the wrapped method consult https://ontio.github.io/documentation/restful_api_en.html . The types '''Transaction''', '''Block''', '''MerkleProof''' and '''Balance''' corresponds to the exact object returned from Ontology blockchain.

===Asset===
A primary focus of Asset API is to enumerate the addresses under user control and initiate a transfer. The request needs to be confirmed by the user.

====getOwnAccounts====
<pre>
function getOwnAccounts(): Promise<string[]>
</pre>

Returns all the accounts associated with logged in user. 

*Â Rejects with '''NO_ACCOUNT''' in case the user is not signed in or has no accounts

====getDefaultAccount====
<pre>
function getDefaultAccount(): Promise<string>
</pre>
Returns currently selected account of logged in user. 

* Rejects with '''NO_ACCOUNT''' in case the user is not signed in or has no accounts

====getPublicKey====
<pre>
function getPublicKey(account: string): Promise<string>
</pre>
Returns public key corresponding to an <code>account</code>. The <code>account</code> must be one of the accounts returned by <code>getOwnAccounts</code>. 

* Rejects with '''NO_ACCOUNT''' in case the user is not signed in or has no accounts
* Rejects with '''WRONG_ACCOUNT''' in case the <code>account</code> is not one of own accounts
* Rejects with '''MALFORMED_ACCOUNT''' in case the <code>account</code> is not a valid account

====makeTransfer====
<pre>
function makeTransfer(sender: string, recipient: string, asset: Asset, amount: number): Promise<string>
</pre>

Initiates a transfer of <code>amount asset</code> from <code>sender</code> account to <code>recipient</code> account. The <code>sender</code> must be one of the accounts returned by <code>getOwnAccounts</code>. 

Returns transaction Id.

* Rejects with '''NO_ACCOUNT''' in case the user is not signed in or has no accounts
* Rejects with '''WRONG_ACCOUNT''' in case the <code>sender</code> is not one of own accounts
* Rejects with '''MALFORMED_ACCOUNT''' in case the <code>sender</code> or <code>recipient</code> is not a valid account
* Rejects with '''CANCELED''' in case the user cancels the request

===Identity===
A primary focus of Identity API is to enumerate the ONT ID identities under user control and initiate a process of adding/removing attribute from the identity. The request needs to be confirmed by the user. 

====getOwnIdentities====
<pre>
function getOwnIdentities(): Promise<string[]>
</pre>

Returns all the identities associated with logged in user.

* Rejects with '''NO_IDENTITY''' in case the user is not signed in or has no identity

====getDefaultIdentity====
<pre>
function getDefaultIdentity(): Promise<string>
</pre>

Returns currently selected identity of logged in user.

* Rejects with '''NO_IDENTITY''' in case the user is not signed in or has no identity

====getPublicKeys====
<pre>
function getPublicKeys(identity: string): Promise<string[]>
</pre>
Returns public keys corresponding to an <code>identity</code>. The <code>identity</code> '''does not''' need to be one of the identities returned by <code>getOwnIdentities</code>. This call must query blockchain by contrast to <code>asset.getPublicKey</code>.

* Rejects with '''MALFORMED_IDENTITY''' in case the <code>identity</code> is not a valid identity

====getDDO====
<pre>
interface OntIdDDO {
    ...
}

function getDDO(identity: string): Promise<OntIdDDO>
</pre>

Queries Description Object of the <code>identity</code>. The <code>identity</code> '''does not''' need to be one of the identities returned by <code>getOwnIdentities</code>. This operation is not signed and therefore does not require user interaction.

* Rejects with '''MALFORMED_IDENTITY''' in case the <code>identity</code> is not a valid identity

====getAttributes====
<pre>
interface OntIdAttribute {
    key: string;
    type: string;
    value: string;
}

function getAttributes(identity: string): Promise<OntIdAttribute[]>
</pre>

Queries attributes attached to the <code>identity</code>. The <code>identity</code> '''does not''' need to be one of the identities returned by <code>getOwnIdentities</code>. This operation is not signed and therefore does not require user interaction.

* Rejects with '''MALFORMED_IDENTITY''' in case the <code>identity</code> is not a valid identity

====addAttributes====
<pre>
function addAttributes(identity: string, attributes: OntIdAttribute[]): Promise<void>
</pre>

Adds attributes to the <code>identity</code>. The <code>identity</code> must be one of the identities returned by <code>getOwnIdentities</code>.

* Rejects with '''NO_IDENTITY''' in case the user is not signed in or has no identity
* Rejects with '''WRONG_IDENTITY''' in case the <code>identity</code> is not one of own identites
* Rejects with '''MALFORMED_IDENTITY''' in case the <code>identity</code> is not a valid identity

====removeAttributes====
<pre>
function removeAttribute(identity: string, key: string): Promise<void>
</pre>

Removes attribute from the <code>identity</code>. The <code>identity</code> must be one of the identities returned by <code>getOwnIdentities</code>.

* Rejects with '''NO_IDENTITY''' in case the user is not signed in or has no identity
* Rejects with '''WRONG_IDENTITY''' in case the <code>identity</code> is not one of own identites
* Rejects with '''MALFORMED_IDENTITY''' in case the <code>identity</code> is not a valid identity

===Message===
This API deals with arbitrary message signing and verification.

====signMessageHash====
<pre>
function signMessageHash(messageHash: string, address: string): Promise<string>
</pre>

Initiates signing of arbitrary <code>messageHash</code> by the account or identity. The <code>address</code> '''must''' be one of the accounts returned by <code>getOwnAccounts</code> or identities returned by <code>getOwnIdentities</code>.

This method does not require the dApp to disclose the message itself, only the hash. 

Because malicious dApp can hash a real prepared transfer transaction and plant it for signing, that posses a risk to the user.
Therefore the hash is prepended with known string '''Ontology message:''', and only this hash is put for signing.

* Rejects with '''NO_ADDRESS''' in case the user is not signed in or has no account or identity
* Rejects with '''WRONG_ADDRESS''' in case the <code>address</code> is not one of own accounts or identites
* Rejects with '''MALFORMED_ADDRESS''' in case the <code>address</code> is not a valid account or identity
* Rejects with '''MALFORMED_MESSAGE''' in case the <code>message</code> is not hex encoded

====verifyMessageHash====
<pre>
function verifyMessageHash(address: string, messageHash: string, address: string, signature: string): Promise<boolean>
</pre>

Verifies that the <code>signature</code> is created by the account or identity over <code>messageHash</code>. The <code>address</code> '''must''' be one of the accounts returned by <code>getOwnAccounts</code> or identities returned by <code>getOwnIdentities</code>.

This method does not require the dApp to disclose the message itself, only the hash. The hash is prepended with known string '''Ontology message:''' and only this hash is put for verification.

* Rejects with '''NO_ADDRESS''' in case the user is not signed in or has no account or identity
* Rejects with '''WRONG_ADDRESS''' in case the <code>address</code> is not one of own accounts or identites
* Rejects with '''MALFORMED_ADDRESS''' in case the <code>address</code> is not a valid account or identity
* Rejects with '''MALFORMED_MESSAGE''' in case the <code>message</code> is not hex encoded
* Rejects with '''MALFORMED_SIGNATURE''' in case the <code>signature</code> is not hex encoded

====verifyMessageHashPk====
<pre>
function verifyMessageHashPk(publicKey: string, messageHash: string, address: string, signature: string): Promise<boolean>
</pre>

Verifies that the <code>signature</code> is created by a private key corresponding to <code>publicKey</code> over <code>messageHash</code>.

This method does not require the dApp to disclose the message itself, only the hash. The hash is prepended with known string '''Ontology message:''' and only this hash is put for verification.

* Rejects with '''MALFORMED_PUBLIC_KEY''' in case the <code>public key</code> is not hex encoded
* Rejects with '''MALFORMED_MESSAGE''' in case the <code>message</code> is not hex encoded
* Rejects with '''MALFORMED_SIGNATURE''' in case the <code>signature</code> is not hex encoded


====signMessage====
<pre>
function signMessage(address: string, message: string): Promise<string>
</pre>

Initiates signing of text <code>message</code> by the account or identity. The <code>address</code> '''must''' be one of the accounts returned by <code>getOwnAccounts</code> or identities returned by <code>getOwnIdentities</code>.

This method provide the dAPI provider with the message body, which it should display to the user prior to signing (e.g.: a contract to sign).

* Rejects with '''NO_ADDRESS''' in case the user is not signed in or has no account or identity
* Rejects with '''WRONG_ADDRESS''' in case the <code>address</code> is not one of own accounts or identites
* Rejects with '''MALFORMED_ADDRESS''' in case the <code>address</code> is not a valid account or identity


====verifyMessage====
<pre>
function verifyMessage(address: string, message: string, address: string, signature: string): Promise<boolean>
</pre>

Verifies that the <code>signature</code> is created by the account or identity over text <code>message</code>. The <code>address</code> '''must''' be one of the accounts returned by <code>getOwnAccounts</code> or identities returned by <code>getOwnIdentities</code>.

* Rejects with '''NO_ADDRESS''' in case the user is not signed in or has no account or identity
* Rejects with '''WRONG_ADDRESS''' in case the <code>address</code> is not one of own accounts or identites
* Rejects with '''MALFORMED_ADDRESS''' in case the <code>address</code> is not a valid account or identity
* Rejects with '''MALFORMED_MESSAGE''' in case the <code>message</code> is not hex encoded


====verifyMessagePk====
<pre>
function verifyMessage(publicKey: string, message: string, address: string, signature: string): Promise<boolean>
</pre>

Verifies that the <code>signature</code> is created by a private key corresponding to <code>publicKey</code> over text <code>message</code>. 

* Rejects with '''MALFORMED_PUBLIC_KEY''' in case the <code>public key</code> is not hex encoded
* Rejects with '''MALFORMED_SIGNATURE''' in case the <code>signature</code> is not hex encoded


===SmartContract===
The main functionality of this component is invocation of smart contract methods.

====invoke====
<pre>
type ParameterType = 'Boolean' | 'Integer' | 'ByteArray' | 'Struct' | 'Map' | 'String';

interface Parameter {
    type: ParameterType;
    value: any;
}

function invoke(account: string, contract: string, method: string, parameters: Parameter[], 
  gasPrice: number, gasLimit: number, addresses: string[]): Promise<any>
</pre>

Initiates a <code>method</code> call to a smart <code>contract</code> with supplied <code>parameters</code>.
The <code>gasPrice</code> and <code>gasLimit</code> are hints for the dAPI provider and it should allow user to override those values before signing. The <code>account</code> will be set as payer of the transaction. It '''must''' be one of the accounts returned by <code>getOwnAccounts</code>. <code>addresses</code> can specify additional accounts or identites whose signature will be required. Every element '''must''' be one of the accounts returned by <code>getOwnAccounts</code> or identities returned by <code>getOwnIdentities</code>.

Smart code execution is two step process:

# The transaction is send to the network.
# The transaction is recorded to the blockchain at a later time.

The <code>invoke</code> function will finish as soon as the transaction is sent to the network. To receive useful data from <code>method</code> execution it is necessary to start listening for events using <code>addEventListener</code>.

* Rejects with '''NO_ACCOUNT''' in case the user is not signed in or has no accounts
* Rejects with '''WRONG_ACCOUNT''' in case the <code>sender</code> is not one of own accounts
* Rejects with '''MALFORMED_ACCOUNT''' in case the <code>account</code> is not a valid account
* Rejects with '''MALFORMED_CONTRACT''' in case the <code>contract</code> is not hex encoded contract address
* Rejects with '''MALFORMED_ADDRESS''' in case the <code>addresses</code> contains at least one address which is not a valid account nor identity


====invokeRead====
<pre>
function invokeRead(contract: string, method: string, parameters: Parameter[]): Promise<any>
</pre>

Initiates a <code>method</code> call to a smart <code>contract</code> with supplied <code>parameters</code> in read only mode (preExec). This kind of method call does not write anything to blockchain and therefore does not need to be signed or paid for. It is processed without user interaction.

* Rejects with '''MALFORMED_CONTRACT''' in case the <code>contract</code> is not hex encoded contract address


====deploy====
<pre>
function deploy(account: string, code: string, name: string, version: string, author: string, 
    email: string, description: string, needStorage: boolean, gasPrice: number, gasLimit: number): Promise<any>
</pre>

Initiates deployment of smart contract. The <code>code</code> parameter represents compiled code of smart contract for NEOVM. The <code>gasPrice</code> and <code>gasLimit</code> are hints for the dAPI provider and it should allow user to override those values before signing. The <code>account</code> will be set as payer of the transaction. It '''must''' be one of the accounts returned by <code>getOwnAccounts</code>

* Rejects with '''NO_ACCOUNT''' in case the user is not signed in or has no accounts
* Rejects with '''WRONG_ACCOUNT''' in case the <code>sender</code> is not one of own accounts
* Rejects with '''MALFORMED_ACCOUNT''' in case the <code>account</code> is not a valid account


====addEventListener====
<pre>
type EventListener = (data: any) => void;

function addEventListener(listener: EventListener): void
</pre>

Starts listening for Notify events.

====removeEventListener====
<pre>
function addEventListener(listener: EventListener): void
</pre>

Stops listening for Notify events.

==Architecture==
The interaction between dApp and Ontology network can be described with this diagram:

[[Image:OEP-6-1.svg|Architecture]]

===Yellow parts===
These components are external to this proposal.

===Green parts===
'''dAPI.js''' is universal implementation of this proposal for direct use by dApp developers.

===Blue parts===
These components all belongs to concrete implementation of dAPI provider. The implementation is out of scope of this proposal, but the implementator must adhere to the protocol used by dAPI.js.

==Rationale==

'''''User story''''': As a '''dApp''' developer, I need to use a lightweight api for integration with Ontology network without requiring my users to share their private keys with me.

==Test Cases==

==Implementation of dAPI.js==
OntologyCommunityDevelopers/ontology-dapi - https://github.com/OntologyCommunityDevelopers/ontology-dapi

==Implementation of dAPI provider==
OntologyCommunityDevelopers/ontology-plugin-wallet - https://github.com/OntologyCommunityDevelopers/ontology-plugin-wallet
